<?php
/**
 * -- Ook! Interpreter --
 * Thank you for downloading my little Ook-Interpreter.
 * If you have any questions about this, just ask me on github!
 *
 * -- How to use --
 * - Read code from file -
 * You read the code from a file by using the readFile()-function
 *
 * - Read code from string -
 * You can directly read the code from a string by using the readString()-function
 *
 * - Run code -
 * You can run the brainfuck code by using the run()-function
 * 
 * - The Config-Variable -
 * Use the config variable to configure how the interpreter acts.
 * Here is a list of the supported config names
 * - cellsize (the maximum size of a memory cell) => either 8 (8 bit), 16 (16 bit) or 32 (32 bit)
 * - infinitememory (if the memory should be infinite) => either true or false
 * - memorysize (if not infinite, how big the memory should be) => any value of type int
 * - memoverflow (what the interpreter should do if the memory cell reaches the maximum cellsize) => either 1 (nothing), 2 (wrap) or 3 (abort)
 * - inputmode (the way the interpreter gets input. The difference is explained at the get_input()-function) => either "string" or "char"
 * 
 * 
 * @license https://github.com/Skayo/Ook!-Interpreter-PHP/blob/master/LICENSE MIT
 * @link https://github.com/Skayo/Ook!-Interpreter-PHP
 * @author Skayo
 */
class BFI {
	private $config = [];

	private $bfcode = []; // cleaned brainfuck code (array of characters)
	private $memory = [];

	private $targets = [];
	private $codePtr = 0; // Pointer in code (current Character)
	private $memPtr = 0; // Pointer in memory
	private $input_queue = [];

	private $max_mem;
	private $cellsize;
	private $infinitemem;

	function __construct($conf) {
		$this->config = $conf;
		$this->checkConfig(); // check if any config-values are missing
		$this->setVars(); // set some vars for shorter code
	}

	private function error($msg) {
		exit($msg);
	}

	private function checkConfig() {
		$defaultconfig = ["cellsize" => 8, "infinitememory" => false, "memorysize" => 30000, "memoverflow" => 2, "inputmode" => "string"]; // default config values and keys
		foreach ($defaultconfig as $confKey => $confVal) {
			if(!isset($this->config[$confKey])) // if the config is not set...
				$this->config[$confKey] = $confVal; // ...set it
		}
	}

	private function setVars() {
		// set cellsize
		switch ($this->config["cellsize"]) {
			case 8:
				$this->cellsize = 255;
				break;
			
			case 16:
				$this->cellsize = 65535;
				break;

			case 32:
				$this->cellsize = 16777215;
				break;

			default:
				$this->error("Config error: cellsize not supported. Supported cellsizes are 8 (8 bit), 16 (16 bit) and 32 (32 bit).");
				break;
		}

		// set max mem
		if(is_numeric($this->config["memorysize"])){
			$this->max_mem = $this->config["memorysize"];
		} else {
			$this->error("Config error: memorysize is not of type int.");
		}

		// set infinite mem
		if($this->config["infinitememory"] == true || $this->config["infinitememory"] == false){
			$this->infinitemem = $this->config["infinitememory"];
		} else {
			$this->error("Config error: infinitememory is not of type boolean. Use true or false.");
		}
	}

	public function readFile($file) {
		if(!file_exists($file)) // test if file exists
			$this->error("File not found: ".$file);
		$this->parse(file_get_contents($file)); // read Ook! code from file
		if(!$this->config["infinitememory"])
			$this->init_memory(); // if infinite memory is not true, fill memory with 0s
		$this->init_targets(); // locate [ and ] in the code
	}

	public function readString($str) {
		$this->parse($str); // read Ook! code from given string
		if(!$this->config["infinitememory"])
			$this->init_memory(); // if infinite memory is not true, fill memory with 0s
		$this->init_targets(); // locate [ and ] in the code
	}

	private function parse($code) {
		$ookcode = []; // temporary because it gets converted to brainfuck

		$code = str_replace("Ook", "", $code); // replace "Ook" to get a simplified code
		$code = str_split($code); // split every character of code
		foreach ($code as $char) {
			if($this->isOokchar($char)) // if the character is a Ook! character...
				array_push($ookcode, $char); // ...append it to the cleaned code array
		}
		
		/*---  Convert to brainfuck code  ---*/
		for ($num=0; $num < count($ookcode); $num+=2) { 
			$char = $ookcode[$num];
			array_push($this->bfcode, $this->OOKtoBF($num, $ookcode));
		}
	}

	private function isOokchar($c) {
		$ookchars = [".", "!", "?"];
		if(in_array($c, $ookchars)) // if the given character exists in the array of valid brainfuck characters...
			return true; // ...return true.
		return false; // else return false
	}

	private function OOKtoBF($cn, $arr){
		if(!isset($arr[$cn + 1]))
			$this->error("Parseing error: Unbalanced use of Ook.");
		$char = $arr[$cn].$arr[$cn + 1];
		switch ($char) {
			case '..':
				return '+';
				break;

			case '!!':
				return '-';
				break;

			case '.?':
				return '>';
				break;
			
			case '?.':
				return '<';
				break;

			case '!?':
				return '[';
				break;

			case '?!':
				return ']';
				break;

			case '!.':
				return '.';
				break;

			case '.!':
				return ',';
				break;

			default:
				$chars = str_split($char); // split to get a better error message
				$this->error("Parseing error: Invalid operation: Ook".$chars[0]." Ook".$chars[1]." at Ook-Number ".$cn."."); // if operation is invalid (for example: ??), throw error
				break;
		}
	}

	private function init_memory() {
		for ($i=0; $i < $this->max_mem; $i++) { 
			$this->memory[$i] = 0; // set all values to 0
		}
	}

	private function init_targets() {
		// no comments for this code. sorry...
		$temp_stack = [];
		foreach ($this->bfcode as $charnum => $char) {
			if($char == '[')
				array_push($temp_stack, $charnum);

			if($char == ']'){
				if(count($temp_stack) == 0)
					$this->error("Parseing error: ] with no matching [.");
				$target = array_pop($temp_stack);
				$this->targets[$charnum] = $target;
				$this->targets[$target] = $charnum;
			}
		}

		if(count($temp_stack) > 0)
			$this->error("Parseing error: [ with no matching ].");
	}

	public function run() {
		while($this->codePtr != count($this->bfcode)){ // while the codePointer is not at the end of the program...
			$op = $this->bfcode[$this->codePtr];
			$this->execute_opcode($op);
			$this->codePtr++;
		}
	}

	private function execute_opcode($op) {
		// no comments for this code. sorry...
		switch ($op) {
			case '>':
				$this->increasePtr();
				break;

			case '<':
				$this->decreasePtr();
				break;

			case '+':
				$this->increaseMem();
				break;

			case '-':
				$this->decreaseMem();
				break;

			case '.':
				echo chr($this->memory[$this->memPtr]);
				break;

			case ',':
				$this->memory[$this->memPtr] = ord($this->get_input());
				break;

			case '[':
				if($this->memory[$this->memPtr] == 0)
					$this->codePtr = $this->targets[$this->codePtr];
				break;

			case ']':
				$this->codePtr = $this->targets[$this->codePtr] - 1;
				break;

		}
	}

	private function increasePtr() {
		$this->memPtr++; // increase memPtr
		if(!$this->infinitemem){ // if infinite memory is disabled...
			if($this->memPtr >= $this->max_mem){ // if memPtr is bigger than or equal to max_mem...
				$this->memPtr = 0; // ...set memPtr to 0
			}
		} else { // if infinite memory is enabled...
			// nothing because it's infinite :)
		}
	}

	private function decreasePtr() {
		$this->memPtr--; // decrease memPtr
		if(!$this->infinitemem){ // if infinite memory is disabled...
			if($this->memPtr < 0){ // if memPtr is less then 0...
				$this->memPtr = $this->max_mem; // ...set memPtr to "end" of memory
			}
		} else { // if infinite memory is enabled...
			if($this->memPtr < 0){ // if memPtr is less then 0...
				$this->memPtr = 0; // ...reset memPtr to zero
			}
		}
	}

	private function increaseMem() {
		$this->memory[$this->memPtr]++; // increase memPtr
		if($this->memory[$this->memPtr] > $this->cellsize){ // if memory cell at pointer is bigger than the maximum allowed cellsize...
			$memoverflow = $this->config["memoverflow"];
			if($memoverflow == 1){ // ...and memoverflow action is 1 (nothing)...
				$this->memory[$this->memPtr] = $this->cellsize; // ...reset memory at pointer cell to the maximum allowed cellsize.

			} elseif($memoverflow == 2) { // ...and memoverflow action is 2 (wrap)...
				$this->memory[$this->memPtr] = 0; // ...set memory cell at pointer to 0.

			} elseif($memoverflow == 3) { // ...and memoverflow action is 3 (abort)...
				$this->error("Memory Overflow. Execution aborted."); // ...abort. 
			}
		} 
	}

	private function decreaseMem() {
		$this->memory[$this->memPtr]--; // decrease memPtr
		if($this->memory[$this->memPtr] < 0){ // if memory cell at pointer is smaller than 0...
			$memoverflow = $this->config["memoverflow"];
			if($memoverflow == 1){ // ...and memoverflow action is 1 (nothing)...
				$this->memory[$this->memPtr] = 0; // ...reset memory cell at pointer to 0.

			} elseif($memoverflow == 2) { // ...and memoverflow action is 2 (wrap)...
				$this->memory[$this->memPtr] = $this->cellsize; // ...set memory cell at pointer to the maximum allowed cellsize

			} elseif($memoverflow == 3) { // ...and memoverflow action is 3 (abort)...
				$this->error("Memory Overflow. Execution aborted."); // ...abort. 
			}
		}
	}

	private function get_input() {
		/*
			inputmode "string" means that the input string is splitted into chars and put in a queue, 
			and if the program calls for input, the first is returned.

			inputmode "char" means that the input is a single char wich is returned to the program
		*/
		
		if($this->config["inputmode"] == "string"){ // if inputmode "string" is configured
			if(count($this->input_queue) == 0){ // if nothing is in the input queue...
				$input = readline(""); // ...get input from user...
				$input = str_split($input); // ...split it into chars...
				foreach ($input as $char) {
					array_push($this->input_queue, $char); // ...and add every char to the queue.
				}
			}

			return array_shift($this->input_queue);
		} elseif($this->config["inputmode"] == "char") { // if inputmode "string" is configured
			$input = readline(""); // get input from user
			while(strlen($input) > 1){	// while input is not a single char...
				$input = readline(""); // ...get input from user again
			}

			return $input;
		} else {
			$this->error("Config error: inputmode not supported. Supported inputmodes are 'char' and 'string'.");
		}
	}
}
?>